# 02. Build System

## Overview

The shadcn/ui build system uses Turborepo with pnpm workspaces to manage a complex monorepo with multiple applications, packages, and intricate build dependencies. This document explains the complete build system architecture.

## Core Technologies

### 1. Turborepo Configuration

```json
// turbo.json
{
  "remoteCache": {
    "enabled": true
  },
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**", "dist/**"]
    },
    "build:registry": {
      "dependsOn": ["^build"],
      "inputs": ["registry/**", "scripts/**"],
      "outputs": ["public/r/**", "registry/__index__.tsx"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {
      "dependsOn": ["^build"]
    },
    "typecheck": {
      "dependsOn": ["^build"]
    }
  }
}
```

### 2. Package Manager Configuration

```yaml
# pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'packages/*'
  - '!**/test/**'
```

```json
// .npmrc
auto-install-peers=true
public-hoist-pattern[]=*eslint*
public-hoist-pattern[]=*prettier*
public-hoist-pattern[]=*typescript*
```

## Build Pipeline Architecture

```
Build Pipeline Flow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Source Code   â”‚    â”‚   TypeScript    â”‚    â”‚   Registry      â”‚
â”‚   Changes       â”‚â”€â”€â”€â–¶â”‚   Compilation   â”‚â”€â”€â”€â–¶â”‚   Generation    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Lint & Test   â”‚    â”‚   Asset Build   â”‚    â”‚   Static Gen    â”‚
â”‚   Validation    â”‚    â”‚   (Next.js)     â”‚    â”‚   (Public API)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Registry Build System

### 1. Registry Generation Process

```typescript
// apps/v4/scripts/build-registry.mts
async function buildRegistry() {
  console.log('ğŸ—ï¸  Building registry...')

  // 1. Generate component index
  await buildRegistryIndex()

  // 2. Generate JSON API files
  await buildRegistryJsonFile()

  // 3. Build public API
  await buildPublicAPI()

  console.log('âœ… Registry build complete')
}

async function buildRegistryIndex() {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`

  for (const item of registry.items) {
    const componentPath = item.files?.[0]?.path
      ? `@/registry/new-york-v4/${item.files[0].path}`
      : ''

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ''}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${item.files?.map(file => {
      const filePath = `registry/new-york-v4/${file.path}`
      return `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ''}"
      }`
    })}],
    component: ${
      componentPath
        ? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => 
        typeof mod[key] === 'function' || typeof mod[key] === 'object'
      ) || item.name
      return { default: mod.default || mod[exportName] }
    })`
        : 'null'
    },
    categories: ${JSON.stringify(item.categories)},
    meta: ${JSON.stringify(item.meta)},
  },`
  }

  index += `
}`

  await fs.writeFile('registry/__index__.tsx', index)
}
```

### 2. Static File Generation

```typescript
// Generate public API files
async function buildPublicAPI() {
  const outputDir = path.join(process.cwd(), 'public/r')

  // Clean output directory
  await rimraf(outputDir)
  await fs.mkdir(outputDir, { recursive: true })

  // Generate index.json
  await fs.writeFile(
    path.join(outputDir, 'index.json'),
    JSON.stringify(registry, null, 2)
  )

  // Generate individual component files
  for (const item of registry.items) {
    const itemDir = path.join(outputDir, 'styles', 'new-york-v4')
    await fs.mkdir(itemDir, { recursive: true })

    await fs.writeFile(
      path.join(itemDir, `${item.name}.json`),
      JSON.stringify(item, null, 2)
    )
  }
}
```

### 3. TypeScript Processing

```typescript
// Process TypeScript files for distribution
async function processTypeScriptFiles(files: RegistryFile[]) {
  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.ES2020,
      module: ModuleKind.ESNext,
      moduleResolution: ModuleResolutionKind.NodeJs,
      allowSyntheticDefaultImports: true,
      esModuleInterop: true,
      skipLibCheck: true,
      strict: true,
    },
  })

  const processedFiles = []

  for (const file of files) {
    const sourceFile = project.createSourceFile(
      file.path,
      await fs.readFile(file.path, 'utf-8'),
      { scriptKind: ScriptKind.TSX }
    )

    // Transform imports
    sourceFile.getImportDeclarations().forEach(importDecl => {
      const moduleSpecifier = importDecl.getModuleSpecifierValue()

      // Fix registry imports
      if (moduleSpecifier.startsWith('@/registry/')) {
        importDecl.setModuleSpecifier(
          moduleSpecifier.replace('@/registry/', '@/components/')
        )
      }
    })

    // Extract exports
    const exports = sourceFile.getExportedDeclarations()

    processedFiles.push({
      ...file,
      content: sourceFile.getFullText(),
      exports: Array.from(exports.keys()),
    })
  }

  return processedFiles
}
```

## CLI Build System

### 1. CLI Package Build

```json
// packages/shadcn/package.json
{
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "test": "vitest run",
    "test:dev": "vitest",
    "typecheck": "tsc --noEmit"
  }
}
```

```typescript
// packages/shadcn/tsup.config.ts
import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  external: ['react', 'react-dom', '@typescript-eslint/parser', 'typescript'],
  banner: {
    js: '#!/usr/bin/env node',
  },
})
```

### 2. Registry Schema Validation

```typescript
// Validate registry items during build
export function validateRegistry(registry: Registry) {
  const errors: string[] = []

  for (const item of registry.items) {
    // Validate schema
    const result = registryItemSchema.safeParse(item)
    if (!result.success) {
      errors.push(`Invalid registry item ${item.name}: ${result.error.message}`)
      continue
    }

    // Validate file references
    for (const file of item.files || []) {
      const filePath = path.resolve(`registry/new-york-v4/${file.path}`)
      if (!existsSync(filePath)) {
        errors.push(`File not found: ${filePath}`)
      }
    }

    // Validate dependencies
    for (const dep of item.registryDependencies || []) {
      if (!registry.items.find(i => i.name === dep)) {
        errors.push(
          `Registry dependency not found: ${dep} (required by ${item.name})`
        )
      }
    }
  }

  if (errors.length > 0) {
    throw new Error(`Registry validation failed:\n${errors.join('\n')}`)
  }
}
```

## Documentation Build System

### 1. MDX Processing (www app)

```javascript
// apps/www/contentlayer.config.js
import { defineDocumentType, makeSource } from 'contentlayer2/source-files'
import rehypeAutolinkHeadings from 'rehype-autolink-headings'
import rehypePrettyCode from 'rehype-pretty-code'
import rehypeSlug from 'rehype-slug'
import remarkGfm from 'remark-gfm'

export const Doc = defineDocumentType(() => ({
  name: 'Doc',
  filePathPattern: `docs/**/*.mdx`,
  contentType: 'mdx',
  fields: {
    title: { type: 'string', required: true },
    description: { type: 'string', required: true },
    published: { type: 'boolean', default: true },
    component: { type: 'boolean', default: false },
  },
  computedFields: {
    slug: {
      type: 'string',
      resolve: doc => `/${doc._raw.flattenedPath}`,
    },
  },
}))

export default makeSource({
  contentDirPath: './content',
  documentTypes: [Doc],
  mdx: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [
      rehypeSlug,
      [
        rehypePrettyCode,
        {
          theme: 'github-dark',
          keepBackground: false,
        },
      ],
      [
        rehypeAutolinkHeadings,
        {
          properties: {
            className: ['subheading-anchor'],
            ariaLabel: 'Link to section',
          },
        },
      ],
    ],
  },
})
```

### 2. Fumadocs Processing (v4 app)

```typescript
// apps/v4/source.config.ts
import { defineDocs, defineConfig } from 'fumadocs-mdx/config'

export const { docs, meta } = defineDocs({
  dir: 'content/docs',
})

export default defineConfig({
  mdxOptions: {
    rehypeCodeOptions: {
      themes: {
        light: 'github-light',
        dark: 'github-dark',
      },
    },
  },
})
```

## Asset Build Pipeline

### 1. Static Asset Processing

```typescript
// Process component screenshots
async function captureComponentScreenshots() {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  })

  try {
    for (const component of registry.items) {
      if (component.type !== 'registry:block') continue

      const page = await browser.newPage()
      await page.setViewport({ width: 1440, height: 900 })

      // Light theme screenshot
      await page.goto(`http://localhost:4000/view/${component.name}`)
      await page.waitForLoadState('networkidle')
      await page.screenshot({
        path: `public/r/styles/new-york-v4/${component.name}-light.png`,
        fullPage: false,
      })

      // Dark theme screenshot
      await page.emulateMedia({ colorScheme: 'dark' })
      await page.screenshot({
        path: `public/r/styles/new-york-v4/${component.name}-dark.png`,
        fullPage: false,
      })

      await page.close()
    }
  } finally {
    await browser.close()
  }
}
```

### 2. CSS Processing

```javascript
// postcss.config.cjs
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
    ...(process.env.NODE_ENV === 'production' ? { cssnano: {} } : {}),
  },
}
```

## Build Optimization

### 1. Caching Strategy

```json
// Turbo caching configuration
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**"],
      "inputs": ["src/**", "components/**", "!**/*.test.*"]
    },
    "build:registry": {
      "dependsOn": [],
      "inputs": [
        "registry/**",
        "scripts/build-registry.mts",
        "apps/v4/registry/**"
      ],
      "outputs": [
        "public/r/**",
        "registry/__index__.tsx",
        "apps/v4/registry/__index__.tsx"
      ]
    }
  }
}
```

### 2. Incremental Builds

```typescript
// Incremental registry building
async function buildRegistryIncremental() {
  const cacheFile = '.turbo/registry-cache.json'
  let cache: Record<string, string> = {}

  // Load existing cache
  if (existsSync(cacheFile)) {
    cache = JSON.parse(await fs.readFile(cacheFile, 'utf-8'))
  }

  const changedItems = []

  for (const item of registry.items) {
    const itemHash = await hashRegistryItem(item)

    if (cache[item.name] !== itemHash) {
      changedItems.push(item)
      cache[item.name] = itemHash
    }
  }

  if (changedItems.length === 0) {
    console.log('ğŸ“¦ Registry cache hit - no changes detected')
    return
  }

  console.log(`ğŸ”„ Rebuilding ${changedItems.length} changed items`)

  // Build only changed items
  await buildChangedItems(changedItems)

  // Update cache
  await fs.writeFile(cacheFile, JSON.stringify(cache, null, 2))
}

async function hashRegistryItem(item: RegistryItem): Promise<string> {
  const crypto = await import('crypto')
  const hasher = crypto.createHash('sha256')

  // Hash item metadata
  hasher.update(
    JSON.stringify({
      name: item.name,
      type: item.type,
      dependencies: item.dependencies,
      registryDependencies: item.registryDependencies,
    })
  )

  // Hash file contents
  for (const file of item.files || []) {
    const filePath = path.resolve(`registry/new-york-v4/${file.path}`)
    if (existsSync(filePath)) {
      const content = await fs.readFile(filePath, 'utf-8')
      hasher.update(content)
    }
  }

  return hasher.digest('hex')
}
```

## CI/CD Integration

### 1. GitHub Actions Workflow

```yaml
# .github/workflows/ci.yml
name: CI
on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - uses: pnpm/action-setup@v2
        with:
          version: 8

      - uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm build

      - name: Build registry
        run: pnpm build:registry

      - name: Type check
        run: pnpm typecheck

      - name: Lint
        run: pnpm lint

      - name: Test
        run: pnpm test

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-outputs
          path: |
            apps/*/dist
            apps/*/.next
            public/r
```

### 2. Deployment Pipeline

```yaml
# .github/workflows/deploy.yml
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - run: pnpm install
      - run: pnpm build
      - run: pnpm build:registry

      - name: Deploy to Vercel
        uses: vercel/action@v1
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}

  deploy-registry:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - run: pnpm install
      - run: pnpm build:registry

      - name: Deploy Registry API
        run: |
          aws s3 sync public/r s3://${{ secrets.REGISTRY_BUCKET }}/r
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CDN_ID }} --paths "/r/*"
```

## Performance Optimization

### 1. Bundle Analysis

```typescript
// Analyze bundle sizes
export function analyzeBundles() {
  const bundleAnalysis = {
    components: {},
    totalSize: 0,
    duplicatedDependencies: [],
  }

  for (const item of registry.items) {
    const bundle = analyzeComponentBundle(item)
    bundleAnalysis.components[item.name] = bundle
    bundleAnalysis.totalSize += bundle.size
  }

  return bundleAnalysis
}
```

### 2. Tree Shaking Optimization

```typescript
// Ensure proper tree shaking
export function optimizeForTreeShaking(code: string): string {
  return (
    code
      // Convert namespace imports to named imports where possible
      .replace(
        /import \* as (\w+) from "(.+)"/g,
        (match, namespace, module) => {
          // Analyze usage and convert to named imports
          return convertToNamedImports(namespace, module, code)
        }
      )
      // Remove unused exports
      .replace(/export \{[^}]+\}/g, match => {
        return removeUnusedExports(match, code)
      })
  )
}
```

This build system ensures fast, reliable builds with proper caching, incremental updates, and optimized output for both development and production environments.
